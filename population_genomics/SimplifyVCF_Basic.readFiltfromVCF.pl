#!/bin/perl
use strict;

# Takes a merged gVCF file (generated by GATK) and simplifies it in the following ways:
# For each individual genotype, detailed genotype information is replaced by a simple call.
#
# Genotypes are assumed to be haploid.  If GATK calls a het, the allele with the greatest depth in the
# genotype is retained and the other discarded.  Ties are "broken" by taking the first allele listed
# (may introduce a tiny reference bias, or possibly towards the individuals at the front of
# the list in the gVCF)
#
# No assumptions about the possible number of bases at a site, i.e., not limited to biallelic sites.
#
# Low-quality and low-depth bases (./., or variants that did not pass the filter) are replaced by "N".
#
# Indel details removed, but some stubs of information retained.
# Insertion locations marked with "I_X" where "X" is the number of bases inserted
# For each site of a deletion, the base is "replaced" by "D_X" where "X" is the total number of contiguous deleted bases
#
# The output VCF will have highly simplified form:  CHROM POS REF IND1 IND2 IND3 (etc). NUM_A NUM_T NUM_G NUM_C, with the
# last four columns totals of the A,T,G,C calls for each site (Ns and indels ignored).  Output is printed to stdout.
#
# In additon to the input gVCF, the program takes two files of (GATK) filtering calls, for snps and indels.  The
# program can be run with only a stub file for indels.

my $vcf_file = $ARGV[0];
#my $snp_filter = $ARGV[0];
#my $indel_filter = $ARGV[2];

my %all_snps = ();
my %all_indels = ();

my %snp_calls = ();
my %indel_calls = ();

#load up a hash with all the locations of SNPs that passed the filter
#open(FILE, "$vcf_file")|| print ("Can't open $vcf_file!\n");
#foreach my $line(<FILE>)
#{
#    chomp($line);
#    
#    if (substr($line,0,1) ne "#") {
#        my @line_info = split("\t", $line);
#        my $tmpChrom = $line_info[0];
#        my $tmpPos = $line_info[1];
#        my $tmpCall = $line_info[6];
#        
#        $all_snps{$tmpChrom.":".$tmpPos} = $line;
#        if ($tmpCall eq 'PASS'){
#            $snp_calls{$tmpChrom.":".$tmpPos} = $line;
#        }
#    }
#}
#close(FILE);
#
#load up a hash with all the locations of INDELs that passed the filter
#open(FILE, "$indel_filter")|| print ("Can't open $indel_filter!\n");
#foreach my $line(<FILE>)
#{
#    chomp($line);
#    
#    if (substr($line,0,1) ne "#") {
#        my @line_info = split("\t", $line);
#        my $tmpChrom = $line_info[0];
#        my $tmpPos = $line_info[1];
#        my $tmpCall = $line_info[6];
#        $all_indels{$tmpChrom.":".$tmpPos} = $line;
#        if ($tmpCall eq 'PASS'){
#            $indel_calls{$tmpChrom.":".$tmpPos} = $line;
#        }
#    }
#}
#close(FILE);
#
#now go through the gVCF, assess each site for each individual
open(FILE, "$vcf_file")|| print ("Can't open $vcf_file!\n");
foreach my $line(<FILE>)
{
    chomp($line);
    my @line_info = split("\t", $line);
    my $tmpChrom = $line_info[0];
    my $tmpPos = $line_info[1];
    my $tmpRef = $line_info[3];
    my $tmpAlt = $line_info[4];
    my $tmpFilter = $line_info[6]; #to check if the filter is passed - Bea

    my @tmpAlleles = split(",",$tmpAlt); #sometimes there are more than one ALT (esp. for indels)
    
    # "output" variables-- called base, and totals for A,T,G,C
    my $tmpBase = 'N';
    
    my $num_A = 0;
    my $num_T = 0;
    my $num_G = 0;
    my $num_C = 0;
    
    if (substr($line,0,1) ne "#") {
 
        #identify the reference allele
        #we have more than one ALT allele, must check to make sure we don't have a degenerate reference site
        if (length($tmpRef) > 1){
            if ((substr($tmpRef, 0, 1) eq 'A') || (substr($tmpRef, 0, 1) eq 'G') || (substr($tmpRef, 0, 1) eq 'T') || (substr($tmpRef, 0, 1) eq 'C')){
                $tmpRef = substr($tmpRef,0,1);
            }
            else {
                $tmpRef = 'N';
            }
        }
        
        #start outputting information for this line
        print $tmpChrom, "\t", $tmpPos, "\t", $tmpRef;





        
        #####################################################################################################################################
        #####################################################################################################################################
        #####################################################################################################################################
        #                                                                                                                                   #
        #                                          Case 1:  not a variant site                                                              #
        #                                                                                                                                   #
        #####################################################################################################################################
        #####################################################################################################################################
        #####################################################################################################################################

        if ($tmpAlt eq '.') { #not called as a variant site-- just read out calls and go!  Only options should be:  reference, or no call (N)
            #For a typical gVCF, calls should start at element 9-- adjust if necessary
            for (my $i = 9; $i < @line_info; $i++){
                
                $tmpBase = 'N'; #default value
                
                if (substr($line_info[$i],0,1) eq '0') {
                    $tmpBase = $tmpRef;
                }
                
                
                if ($tmpBase eq 'A') {
                    $num_A++;
                }
                if ($tmpBase eq 'T') {
                    $num_T++;
                }
                if ($tmpBase eq 'G') {
                    $num_G++;
                }
                if ($tmpBase eq 'C') {
                    $num_C++;
                }
                
                
                print "\t",$tmpBase;
                
            } #finished going through the lines
            print "\t",$num_A,"\t",$num_T,"\t",$num_G,"\t",$num_C,"\n";
        }
        else { #called as a variant site
            #####################################################################################################################################
            #####################################################################################################################################
            #####################################################################################################################################
            #                                                                                                                                   #
            #                                          Case 2A:  possible indel                                                                 #
            #                                                                                                                                   #
            #####################################################################################################################################
            #####################################################################################################################################
            #####################################################################################################################################

            if (1 == 2){
            # if (exists $all_indels{$tmpChrom.":".$tmpPos}){ # we have a new possible indel.
                #passed indel filter
                if (exists $indel_calls{$tmpChrom.":".$tmpPos}){
                    for (my $i = 9; $i < @line_info; $i++){
                        $tmpBase = 'N';
                        my @genotype_details = split(":",$line_info[$i]);
                        my @allele_nums = split("/", $genotype_details[0]);
                        my $alleleMax_num = 0;
                        
                        my @allele_depths = split(",",$genotype_details[2]);
                        if ($allele_depths[0] >= $allele_depths[1]){
                            $alleleMax_num = $allele_nums[0];
                        }
                        else{
                            $alleleMax_num = $allele_nums[1];
                        }
                        
                        if (substr($line_info[$i],0,1) eq '.') {
                            $tmpBase = 'N';
                        }
                        else { # assess the allelic state of the call.
                            # We can assess the size of the insertion, not going to
                            # do it for deletions (too hard for multiple samples)
                            
                            #choices are:  * (deletion), 0 (ref), or some insertion that needs characterization
                            if ($alleleMax_num ne '.'){
                                # "." shouldn't be possible here, but just in case!
                                if ($tmpAlleles[$alleleMax_num - 1] eq '*') {
                                    $tmpBase = 'D_X';
                                }
                                else{
                                    if ($allele_nums[1] eq '.'){
                                        if ($alleleMax_num == 0){
                                            $tmpBase = $tmpRef;
                                        }
                                        else{
                                            my $allele_size = length($tmpAlleles[$alleleMax_num-1]);
                                            if ($allele_size == 1){
                                                $tmpBase = $tmpAlleles[$alleleMax_num-1];
                                            }
                                            else{
                                                $allele_size--;
                                                $tmpBase = "I_".$allele_size;
                                            }
                                        }
                                    }
                                }
 
                            }
                        }
                        
                        #add whatever we got for this line to the totals                       
                        if ($tmpBase eq 'A') {
                            $num_A++;
                        }
                        if ($tmpBase eq 'T') {
                            $num_T++;
                        }
                        if ($tmpBase eq 'G') {
                            $num_G++;
                        }
                        if ($tmpBase eq 'C') {
                            $num_C++;
                        }
                        
                        print "\t",$tmpBase;

                        
                    } #finished going through the lines
                    
                    print "\t",$num_A,"\t",$num_T,"\t",$num_G,"\t",$num_C,"\n";

                } #end passed indel routine
                else{ #failed indel filter-- keep only good ref calls, everyone else gets an N
                    for (my $i = 9; $i < @line_info; $i++){
                        $tmpBase = 'N';
                        
                        #easy case first:  solid reference calls in the genotype (ignoring hets since the polymorphism itself failed the filter)
                        if (substr($line_info[$i],0,1) eq '0') {
                            $tmpBase = substr($tmpRef,0,1);
                        }
                        else { #possibilities are:  reference, a deleted base, or an insertion of some size (relative to the reference)
                             if (substr($line_info[$i],0,1) eq '.') {
                                $tmpBase = 'N';
                            }
                            else {
                                # if this is a failed insertion in which the first base matches the reference,
                                # go ahead and call it for the ref (discarding other inserted sites as unsupported and
                                # NOT RETAINING INFORMATION ABOUT AN POSSIBLE INDEL AT THIS SITE).
                                my @genotype_details = split(":",$line_info[$i]);
                                my @allele_nums = split("/", $genotype_details[0]);
                                my $alleleMax_num = 0;
                                
                                my @allele_depths = split(",",$genotype_details[2]);
                                if ($allele_depths[0] >= $allele_depths[1]){
                                    $alleleMax_num = $allele_nums[0];
                                }
                                else{
                                    $alleleMax_num = $allele_nums[1];
                                }
                                if (substr($tmpAlleles[$alleleMax_num-1],0,1) eq $tmpRef) {
                                    $tmpBase = $tmpRef
                                }
                            }
                        }
                        
                        #add whatever we got for this line to the totals
                         if ($tmpBase eq 'A') {
                            $num_A++;
                        }
                        if ($tmpBase eq 'T') {
                            $num_T++;
                        }
                        if ($tmpBase eq 'G') {
                            $num_G++;
                        }
                        if ($tmpBase eq 'C') {
                            $num_C++;
                        }
                  
                        print "\t",$tmpBase;
                        
                    } #finished going through the lines
                    
                    print "\t",$num_A,"\t",$num_T,"\t",$num_G,"\t",$num_C,"\n";
                
                    
                }#end filter-failed indel routine
            }#  end active indel routine
            
            #####################################################################################################################################
            #####################################################################################################################################
            #####################################################################################################################################
            #                                                                                                                                   #
            #                                          Case 2B:  possible SNP                                                                   #
            #                                                                                                                                   #
            #####################################################################################################################################
            #####################################################################################################################################
            #####################################################################################################################################
            
            else{ #should be a plain-vanilla SNP variant here-- not part of a multi-bp insertion
                #if (exists $snp_calls{$tmpChrom.":".$tmpPos}) {
                #if (1==1){
                if ($tmpFilter eq 'PASS'){ ##check if the SNP passed the filter - Bea
                    for (my $i = 9; $i < @line_info; $i++){
                        $tmpBase = 'N';
                        my @genotype_details = split(":",$line_info[$i]);
                        my @allele_nums = split("/", $genotype_details[0]);
                        my $alleleMax_num = 0;
                        
                        my @allele_depths = split(",",$genotype_details[2]);
                        if ($allele_depths[0] >= $allele_depths[1]){
                            $alleleMax_num = $allele_nums[0];
                        }
                        else{
                            $alleleMax_num = $allele_nums[1];
                        }
                        
                        if ($alleleMax_num ne '.'){
                            if ($tmpAlleles[$alleleMax_num - 1] eq '*') {
                                $tmpBase = '-';
                                #$tmpBase = 'D_X';
                            }
                            else{
                                
                                if ($alleleMax_num==0){
                                    $tmpBase = $tmpRef;
                                }
                                else{
                                    $tmpBase = $tmpAlleles[$alleleMax_num - 1];
                                    if ($tmpAlleles[$alleleMax_num - 1] eq '*') {
                                        $tmpBase = '-';
                                 #       $tmpBase = 'D_X';
                                    }
                                }
                            }
                            
                            #add whatever we got for this line to the totals
                            if ($tmpBase eq 'A') {
                                $num_A++;
                            }
                            
                            if ($tmpBase eq 'T') {
                                $num_T++;
                            }
                            
                            if ($tmpBase eq 'G') {
                                $num_G++;
                            }
                            if ($tmpBase eq 'C') {
                                $num_C++;
                            }
                            
 
                        }
                        print "\t",$tmpBase;

                    } #finished going through all the lines, now print summaries
                    print "\t",$num_A,"\t",$num_T,"\t",$num_G,"\t",$num_C,"\n";
                    
                }
                else { #failed SNP filter-- keep only 0/0 calls, everyone else gets an N
                     for (my $i = 9; $i < @line_info; $i++){
                        $tmpBase = 'N';
                        if (substr($line_info[$i],0,3) eq '0/0') {
                            $tmpBase = $tmpRef;
                        }
                        
                        #add whatever we got for this line to the totals
                        if ($tmpBase eq 'A') {
                            $num_A++;
                        }
                        if ($tmpBase eq 'T') {
                            $num_T++;
                        }
                        if ($tmpBase eq 'G') {
                            $num_G++;
                        }
                        if ($tmpBase eq 'C') {
                            $num_C++;
                        }
                        
                        print "\t",$tmpBase;
                        
                        
                    } #finished going through the lines, now print summaries
                    print "\t",$num_A,"\t",$num_T,"\t",$num_G,"\t",$num_C,"\n";
                }
            }
        }
    }
    #####################################################################################################################################
    #####################################################################################################################################
    #####################################################################################################################################
    #                                                                                                                                   #
    #                                          Case 3:  Informational line                                                              #
    #                                                                                                                                   #
    #####################################################################################################################################
    #####################################################################################################################################
    #####################################################################################################################################

    else {
        if (substr($line,0,2) eq "##"){
            print $line,"\n";
        }
        else { #print a header for the limited info-- chrom, pos, and the line names
            print "CHROM\tPOS\tMELREF";
            my @line_info = split("\t",$line);
            for (my $i = 9; $i < @line_info; $i++) {
                print "\t",$line_info[$i];
            }
            print "\tnum_A\tnum_T\tnum_G\tnum_C\n";
        }
    }
} # end loop over lines in file

close(FILE);


